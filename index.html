<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Earthquake Visualization</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="css/style.css">
    <link rel="icon" type="image/jpeg" href="favicon.jpg">
</head>
<body>
    <h1>Earthquake Visualization (2024-2025)</h1>
    <div class="container">
        <div class="controls">

            <label for="mapStyle">Map Style:</label>
            <select id="mapStyle">
                <option value="osm">OpenStreetMap</option>
                <option value="satellite">Esri Satellite</option>
                <option value="topo">Topographic</option>
            </select>

            <label for="magnitude">Magnitude:</label>
            <select id="magnitudeFilter" name="magnitudeFilter">
                <option value="greater">Greater than</option>
                <option value="less">Less than</option>
                <option value="between">Between</option>
            </select>
            
            <input type="number" id="magnitudeValue1" placeholder="Enter value" min="1" max="8">
            <input type="number" id="magnitudeValue2" placeholder="Enter second value" style="display: none;" min="1" max="8">            

            <label for="depth">Depth Range (km):</label>
            <input type="range" id="depth" min="0" max="700" step="10">

            <label for="timeRange">Time Range:</label>
            <input type="date" id="startTime">
            <input type="date" id="endTime">

            <button onclick="applyFilters()">Apply Filters</button>
            <button onclick="resetFilters()">Reset</button>

            <h3>Animation Controls</h3>
            <label for="speed">Speed (ms per day):</label>
            <input type="number" id="speed" value="500">
            <button onclick="startAnimationUI()">Start Animation</button>
            <button onclick="stopAnimation()">Stop Animation</button>
        </div>
        
        <div id="map"></div>
    </div>

    <div class="visualizations">
        <h2>Earthquake Data Visualizations</h2>
        <div id="magnitudeChart"></div>
        <div id="durationChart"></div>
        <div id="depthChart"></div>
    </div>

    <script>
        var map = L.map('map', {
            center: [20, 0],
            zoom: 2,
            maxZoom: 10,   // Set maximum zoom level
            minZoom: 2,    // Set minimum zoom level
            maxBounds: [
                [-90, -180], // southwest corner
                [90, 180]    // northeast corner
            ],
            worldCopyJump: true,  // Prevent map from wrapping around
        }).setView([20, 0], 2);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        let earthquakeData = [];

        async function loadEarthquakeData() {
            const data = await d3.csv("data/query.csv");
            data.forEach(d => {
                d.latitude = +d.latitude;
                d.longitude = +d.longitude;
                d.magnitude = +d.mag;
                d.depth = +d.depth;
                d.time = new Date(d.time);
            });
            earthquakeData = data;
            updateVisualization();
            updateCharts();
        }

        var colorScale = d3.scaleSequential(d3.interpolateReds)
            .domain([3, 8]);

        function updateVisualization(filters = {}) {
            // Remove any existing markers from the map
            map.eachLayer(layer => {
                if (layer instanceof L.CircleMarker) {
                    map.removeLayer(layer);
                }
            });

            let filteredData = earthquakeData.filter(d => {
                // Magnitude filtering based on the selected filter type
                let isMagnitudeValid = true;

                if (filters.magnitude) {
                    const [minMag, maxMag] = filters.magnitude;

                    if (minMag && maxMag) {
                        // Between
                        isMagnitudeValid = d.magnitude >= minMag && d.magnitude <= maxMag;
                    } else if (minMag) {
                        // Greater than
                        isMagnitudeValid = d.magnitude > minMag;
                    } else if (maxMag) {
                        // Less than
                        isMagnitudeValid = d.magnitude < maxMag;
                    }
                }

                // Apply the rest of the filters
                return isMagnitudeValid &&
                    (!filters.startTime || d.time >= filters.startTime) &&
                    (!filters.endTime || d.time <= filters.endTime) &&
                    (!filters.depth || d.depth >= filters.depth[0] && d.depth <= filters.depth[1]);
            });

            // If no data matches the filters, you might want to show a message
            if (filteredData.length === 0) {
                console.log('No data matches the current filters.');
            }

            // Loop through filtered data and add markers to the map
            filteredData.forEach(d => {
                L.circleMarker([d.latitude, d.longitude], {
                    radius: d.magnitude * 2,
                    fillColor: colorScale(d.magnitude),
                    color: "#000",
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(map)
                .bindPopup(`
                    <strong>Location:</strong> ${d.place} <br>
                    <strong>Magnitude:</strong> ${d.magnitude} <br>
                    <strong>Depth:</strong> ${d.depth} km <br>
                    <strong>Time:</strong> ${d.time.toUTCString()}
                `);
            });
        }

    var layers = {
        "osm": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }),
        "satellite": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: '&copy; Esri'
        }),
        "topo": L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenTopoMap'
        })
    };

    // Set initial layer
    var currentLayer = layers["osm"];
    currentLayer.addTo(map);

    document.getElementById("mapStyle").addEventListener("change", function(event) {
        map.removeLayer(currentLayer);
        currentLayer = layers[event.target.value];
        currentLayer.addTo(map);
    });

        // Function to handle the dropdown change
document.getElementById('magnitudeFilter').addEventListener('change', function() {
    const value2Input = document.getElementById('magnitudeValue2');
    if (this.value === 'between') {
        value2Input.style.display = 'inline';  // Show second input for "Between"
    } else {
        value2Input.style.display = 'none';  // Hide second input for other options
    }
});

function applyFilters() {
    // Get the magnitude filter type from the dropdown
    const magnitudeFilter = document.getElementById('magnitudeFilter').value;
    let magnitudeRange = null;

    // Get the selected values for magnitude
    const magnitude1 = parseFloat(document.getElementById("magnitudeValue1").value);
    let magnitude2 = parseFloat(document.getElementById("magnitudeValue2").value);

    // Validate magnitude range
    if (isNaN(magnitude1) || magnitude1 < 1 || magnitude1 > 8) {
        alert("Please enter a valid magnitude between 1 and 8.");
        return;
    }

    if (magnitudeFilter === "between") {
        if (isNaN(magnitude2) || magnitude2 < 1 || magnitude2 > 8) {
            alert("Please enter a valid second magnitude between 1 and 8.");
            return;
        }
    }

    // Apply the filter based on the selected dropdown option
    if (magnitudeFilter === "greater" && !isNaN(magnitude1)) {
        magnitudeRange = [magnitude1, 8];  // Greater than magnitude1 and less than or equal to 8
    } else if (magnitudeFilter === "less" && !isNaN(magnitude1)) {
        magnitudeRange = [1, magnitude1];  // Greater than or equal to 1 and less than magnitude1
    } else if (magnitudeFilter === "between" && !isNaN(magnitude1) && !isNaN(magnitude2)) {
        if (magnitude1 > magnitude2) {
            [magnitude1, magnitude2] = [magnitude2, magnitude1];  // Swap to ensure lower value is first
        }
        magnitudeRange = [magnitude1, magnitude2];  // Between magnitude1 and magnitude2
    }

    // Other filter values
    let depthValue = document.getElementById("depth").value.trim();
    let startTime = document.getElementById("startTime").value ? new Date(document.getElementById("startTime").value) : null;
    let endTime = document.getElementById("endTime").value ? new Date(document.getElementById("endTime").value) : null;

    // Compute min and max depth
    let minDepth = Math.min(...earthquakeData.map(d => d.depth));
    let maxDepth = Math.max(...earthquakeData.map(d => d.depth));

    // Apply depth filter only if depthValue is valid
    let depthRange = null;
    if (depthValue && !isNaN(depthValue)) {
        depthRange = [minDepth, +maxDepth];
    } else {
        // No depth filter applied
        depthRange = [minDepth, maxDepth];
    }

    // Apply the filters
    updateVisualization({
        magnitude: magnitudeRange,
        depth: depthRange,
        startTime: startTime,
        endTime: endTime
    });

    updateCharts();
}

function resetFilters() {
    document.getElementById("magnitudeValue1").value = "";
    document.getElementById("magnitudeValue2").value = "";
    document.getElementById("magnitudeFilter").value = "greater";  // Default to "Greater than"
    document.getElementById("magnitudeValue2").style.display = "none";
    document.getElementById("depth").value = 350;
    document.getElementById("startTime").value = "";
    document.getElementById("endTime").value = "";
    // Reset the map layer
    document.getElementById("mapStyle").value = "osm";
    map.removeLayer(currentLayer);
    currentLayer = layers["osm"]; // Ensure "osm" exists in your layers object
    currentLayer.addTo(map);
    // document.getElementById("speed").value = 500;
    updateVisualization();
    updateCharts();
}

        let animationInterval;
        let accumulatedData = [];

        function startAnimation(startTime, endTime, speed) {
            let currentTime = new Date(startTime);
            accumulatedData = [];
            clearInterval(animationInterval);
            animationInterval = setInterval(() => {
                if (currentTime > endTime) {
                    clearInterval(animationInterval);
                    return;
                }
                accumulatedData = earthquakeData.filter(d => d.time <= currentTime);
                updateVisualization({ startTime: startTime, endTime: currentTime });
                currentTime.setUTCDate(currentTime.getUTCDate() + 1);
            }, speed);
        }

        function startAnimationUI() {
            let startTime = new Date(document.getElementById("startTime").value);
            let endTime = new Date(document.getElementById("endTime").value);
            let speed = document.getElementById("speed").value;

            if (!startTime || !endTime || isNaN(startTime) || isNaN(endTime)) {
                alert("Please select a valid time range.");
                return;
            }

            startAnimation(startTime, endTime, speed);
        }

        function stopAnimation() {
            clearInterval(animationInterval);
        }

        function updateCharts() {
        // Clear existing charts
        d3.select("#magnitudeChart").html("");
        d3.select("#durationChart").html("");
        d3.select("#depthChart").html("");

        const width = 1400;
        const height = 300;
        const margin = { top: 20, right: 20, bottom: 50, left: 50 }; // Added margins for axes
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Magnitude Chart
        let magnitudeData = earthquakeData.map(d => d.magnitude);

        // Define binning function
        let histogram = d3.histogram()
            .domain([d3.min(magnitudeData), d3.max(magnitudeData)]) // Min and max range
            .thresholds(d3.range(0, d3.max(magnitudeData) + 0.5, 0.5)); // Bin size of 0.5

        let bins = histogram(magnitudeData); // Compute bins

        let magnitudeChart = d3.select("#magnitudeChart")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", `translate(${margin.left}, ${margin.top})`);

        let xScale = d3.scaleBand()
            .domain(bins.map(d => d.x0)) // Bin start values as categories
            .range([0, innerWidth])
            .padding(0.1);

        let yScale = d3.scaleLinear()
            .domain([0, d3.max(bins, d => d.length)]) // Count of earthquakes per bin
            .range([innerHeight, 0]);

        magnitudeChart.selectAll(".bar")
            .data(bins)
            .enter()
            .append("rect")
            .attr("class", "bar")
            .attr("x", d => xScale(d.x0))
            .attr("y", d => yScale(d.length))
            .attr("width", xScale.bandwidth())
            .attr("height", d => innerHeight - yScale(d.length))
            .attr("fill", "steelblue");

        // Add X and Y Axes
        magnitudeChart.append("g")
            .attr("transform", `translate(0, ${innerHeight})`)
            .call(d3.axisBottom(xScale).tickFormat(d3.format(".1f"))); // Format as 1 decimal place

        magnitudeChart.append("g")
            .call(d3.axisLeft(yScale).ticks(5));

        // Duration Chart
        earthquakeData.forEach(d => d.time = new Date(d.time));

        // Aggregate data by month (YYYY-MM format)
        let durationData = d3.rollup(
            earthquakeData,
            v => v.length,
            d => d3.timeFormat("%Y-%m")(d.time)  // Format as "YYYY-MM"
        );

        // Convert rollup map to sorted array
        let durationArray = Array.from(durationData, ([key, value]) => ({ date: key, count: value }))
            .sort((a, b) => d3.ascending(a.date, b.date));

        let durationChart = d3.select("#durationChart")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", `translate(${margin.left}, ${margin.top})`);

        // X Scale - Now using the formatted "YYYY-MM" strings
        let xScaleDuration = d3.scaleBand()
            .domain(durationArray.map(d => d.date)) // Use formatted dates as categories
            .range([0, innerWidth])
            .padding(0.1);

        let yScaleDuration = d3.scaleLinear()
            .domain([0, d3.max(durationArray, d => d.count)])
            .range([innerHeight, 0]);

        // Bars
        durationChart.selectAll(".bar")
            .data(durationArray)
            .enter()
            .append("rect")
            .attr("class", "bar")
            .attr("x", d => xScaleDuration(d.date))
            .attr("y", d => yScaleDuration(d.count))
            .attr("width", xScaleDuration.bandwidth())  // Adjust width dynamically
            .attr("height", d => innerHeight - yScaleDuration(d.count))
            .attr("fill", "steelblue");

        // X Axis
        durationChart.append("g")
            .attr("transform", `translate(0, ${innerHeight})`)
            .call(d3.axisBottom(xScaleDuration))
            .selectAll("text") 
            .attr("transform", "rotate(-45)") // Rotate labels for better readability
            .style("text-anchor", "end");

        // Y Axis
        durationChart.append("g")
            .call(d3.axisLeft(yScaleDuration));


        // Depth Chart
        let depthData = d3.rollup(earthquakeData, v => v.length, d => Math.floor(d.depth / 50) * 50);
        let depthChart = d3.select("#depthChart")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", `translate(${margin.left}, ${margin.top})`);

        let xScaleDepth = d3.scaleBand()
            .domain(Array.from(depthData.keys()))
            .range([0, innerWidth])
            .padding(0.1);

        let yScaleDepth = d3.scaleLinear()
            .domain([0, d3.max(depthData.values())])
            .range([innerHeight, 0]);

        depthChart.selectAll(".bar")
            .data(Array.from(depthData.entries()))
            .enter()
            .append("rect")
            .attr("class", "bar")
            .attr("x", d => xScaleDepth(d[0]))
            .attr("y", d => yScaleDepth(d[1]))
            .attr("width", xScaleDepth.bandwidth())
            .attr("height", d => innerHeight - yScaleDepth(d[1]))
            .attr("fill", "orange");

        // Add X and Y Axes
        depthChart.append("g")
            .attr("transform", `translate(0, ${innerHeight})`)
            .call(d3.axisBottom(xScaleDepth));

        depthChart.append("g")
            .call(d3.axisLeft(yScaleDepth));
    }

        loadEarthquakeData();
    </script>
</body>
</html>
